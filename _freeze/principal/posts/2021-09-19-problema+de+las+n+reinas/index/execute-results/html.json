{
  "hash": "d6dfb92fe1f89d22330a8294da1dc755",
  "result": {
    "markdown": "---\ntitle: \"Problema de las n - reinas\"\ndescription: \"Problema de búsqueda de soluciones\"\n# author: Daniel Franzani\ndate: '2021-09-19'\ncategories:\n  - R\n  - Heurística\n  - Búsqueda\nlang: es\n---\n\n\n\n\nEl problema de las reinas de ajedrez o mejor conocido como el de las $n$ - reinas, consiste en poner $n$ reinas en un tablero de ajedrez de dimensión $n\\times n$ casillas (un grilla o matriz cuadrada) de tal manera que ninguna reina pueda \"capturar\" a otra (una reina puede capturar a otra si se encuentra en su misma fila, columna o diagonal). Por ende, la finalidad de problema es encontrar la (s) distribución (es) de las $n$ reinas en el tablero.\n\nSe aborda el problema bajo la perspectiva de búsqueda con un enfoque desinformado, es decir, no conocemos característica alguna de la solución (estado final). Esto implica, que debemos usar las condiciones descritas en problema para poder evaluar si una solución a proponer es factible. \n\nA continuación se da a conocer dos opciones posibles para solucionar este problema. Sin embargo,\n\n## Opción 1\n\nEste enfoque evalúa los caminos uno a uno, hasta determinar si constituyen una posible solución. En primer lugar, se declara la función para definir la cantidad de reinas que se desean colocar en el tablero.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-1_496d550ed7c10d66aba4215a1a62d8e6'}\n\n```{.r .cell-code}\nopcion1 = function(){\n  \n  reinas = as.integer(readline(\"Número de reinas: \"))\n```\n:::\n\n\nA continuación, se define una función que evalúa si una reina dada las condiciones de \"captura\". En los parámetros de la función se pide el tablero `aux.square` (con las reinas ya colocadas), la fila `i`, la columna `j` en donde se desea colocar una reina, y el `valor` de la reina (se considera 1 como el valor que representan a una reina en la casilla $i,j$, por defecto las casillas el tablero son 0).\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_042de19632f44540d4689d6f3d7c539c'}\n\n```{.r .cell-code}\n  possible = function(aux.square,i,j,valor){\n```\n:::\n\n\nLuego, se asigna a la casilla candidata de posible posición el valor de 1 (no hay otra opción), además se crean las variables de `aux.col` y `aux.row`, las cuales determinan si el `aux.square` cumple con el requisito de que las reinas no se capturen en las filas y columnas. Este requisito se determina calculando la suma de de las filas y columnas, ya que al estar compuesto por ceros y unos, un valor superior a 1 indica que el criterio no se cumple.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-3_e543c558c0e4bcd5b16e1ef1147c6d55'}\n\n```{.r .cell-code}\n    aux.square[i,j] = valor\n\n    aux.col = apply(aux.square, 2, FUN = function(colum){\n      if(sum(colum) <= 1) return(TRUE)\n      else return(FALSE)\n    })\n    aux.col = ifelse(sum(!aux.col) == 0, TRUE, FALSE)\n    \n    aux.row = apply(aux.square, 1, FUN = function(rows){\n      if(sum(rows) <= 1) return(TRUE)\n      else return(FALSE)\n    })\n    aux.row = ifelse(sum(!aux.row) == 0, TRUE, FALSE)\n```\n:::\n\n\nDel mismo modo, se desea determinar las sumas en las diagonales del tablero (no es necesario considerar una diagonal de 1 casilla, pero de todas formas no afecta el procedimiento del *script*). La variable `diag.principales` guarda el valor de verdadero o falso respecto a la suma de las casillas de las diagonales principales (al igual que las filas y columnas, estas no deben sumar más de 1).\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-4_bb984cb5d69ecd13f733560c50898967'}\n\n```{.r .cell-code}\n    diag.principales = c(0,0)\n    \n    for (i in 1:queens) {\n      diag.principales[1] = sum(diag.principales[1],aux.square[i,i])\n      diag.principales[2] = sum(diag.principales[2],aux.square[i,(queens - i + 1)])\n    }\n    \n    diag.principales = ifelse(diag.principales <= 1, TRUE, FALSE)\n    diag.principales = ifelse(sum(diag.principales) == 2, TRUE, FALSE)\n```\n:::\n\n\nPara las \"diagonales secundarias\" (corresponden a todas las diagonales que se pueda formar y que no sean las principales) es posible determinarlas a partir de casillas de la primer fila de la matriz, sin considerar los extremos, ya que como se comentó, no es necesario considerar las diagonales compuestas por una casillas (esquinas).\n\nLos casillas de la primera fila que permite determinar todas las diagonales secundarias se guardará en la variable `key.points`.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-5_4f5e54fd7eaeb450ad06a1902cf7f88d'}\n\n```{.r .cell-code}\n    key.points = matrix(c(rep(1,(queens - 2)), seq(2,(queens - 1))),\n                        ncol = 2, nrow = (queens - 2))\n```\n:::\n\n\nLa función `diags()` que determina las diagonales secundarias y verifica las sumas de estas mediante la función `suma.diag()`. La función `suma.diag()` recibe como argumento las diagonales secundarias y retorna si es verdadero o falso que la suma de las casillas de las componen es menor o igual a 1.\n\nPor otro lado, la variable `report.diag` guarda los valores de las diagonales que se generan a partir de los `key.points`. La relación de como se determinan estás casillas, está expresada en las variables `first.diag`, `second.diag`, `third.diag` y `fourth.diag`.\n\nLuego la variable `aux.sumas` guarda los los resultados de la función `suma.diag()` ya mencionada, cuando recibe de argumento la variable `report.diag`.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-6_2b1d2b32eb89a11af688c84a2cdbfd98'}\n\n```{.r .cell-code}\n    diags = function(aux.key.points){\n      \n      suma.diag = function(M){\n        x = M[1,]; y = M[2,]\n         # Puntos entre los extremos de las diagonales, \n         # se obtiene restando las coordenadas de fila y sumando (1,1)\n        n = abs(y[1] -  x[1]) - 1\n        suma = aux.square[x[1],x[2]] + aux.square[y[1],y[2]]\n        if(n >0){\n          for (i in 1:n) {\n            if(x[1] < y[1] & x[2] > y[2]) suma = suma + aux.square[(x[1]+i),(x[2]-i)]\n            if(x[1] < y[1] & x[2] < y[2]) suma = suma + aux.square[(x[1]+i),(x[2]+i)]\n            if(x[1] > y[1] & x[2] < y[2]) suma = suma + aux.square[(x[1]-i),(x[2]+i)]\n            if(x[1] > y[1] & x[2] > y[2]) suma = suma + aux.square[(x[1]-i),(x[2]-i)]\n          }\n        }\n        if(suma <= 1) return(TRUE)\n        else return(FALSE)\n      }\n      \n      report.diag = list()\n      \n      # Se recorre la matriz de puntos claves, por cada uno\n      # se busca las diagonales que se generan\n      for (i in 1:dim(aux.key.points)[1]) { \n        \n        first.diag = rbind(aux.key.points[i,],c(aux.key.points[i,2],aux.key.points[i,1]))\n        second.diag = rbind(first.diag[2,], first.diag[2,] + c(1,1)*(queens - aux.key.points[i,2]))\n        third.diag = rbind(second.diag[2,], c(second.diag[2,2],second.diag[2,1])) \n        fourth.diag = rbind(third.diag[2,], first.diag[1,])\n        \n        aux.diags = list(first.diag, second.diag,third.diag, fourth.diag)\n        aux.sumas = lapply(aux.diags, function(x){ \n          return(suma.diag(x))\n        })\n        report.diag[[i]] = unlist(aux.sumas)\n      }\n      return(report.diag)\n    }\n```\n:::\n\n\nEl resultado de la función `diags()` se guarda en la variable `diag.secundarias`, que finalmente contiene la suma de cada diagonal secundaria, para luego verificar que en cada una de ellas se cumple el criterio de que no sea mayor a 1, es decir que las reinas no se captura entre si.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-7_716b1653ccf0ead3e91466d3094daf7b'}\n\n```{.r .cell-code}\n    diag.secundarias = diags(key.points)\n    diag.secundarias = ifelse(sum(!unlist(diag.secundarias)) == 0, TRUE, FALSE)\n```\n:::\n\n\nLos criterios sobre las diagonales son unificados como una único resultado en la variable `diagonales`. En este punto finaliza la función `possible()`, retornando un valor de verdadero o falso sobre el cumplimiento de los criterios (filas, columnas y diagonales).\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-8_0c62bde4c86190ad410911133b88ae5d'}\n\n```{.r .cell-code}\n    diagonales = ifelse(diag.principales == TRUE & diag.secundarias == TRUE, TRUE, FALSE)\n    \n    # Verificación en conjunto\n    if(aux.col == TRUE & aux.row == TRUE & diagonales == TRUE) return(TRUE) \n    else return(FALSE)\n    \n  }\n```\n:::\n\n\nPara finalizar, se declara la función `solve()` (recursiva), la cual evalúa en orden las casillas del tablero (por fila de izquierda a derecha) determinando si son posiciones admisibles para una solución. De este modo, la función sigue en proceso hasta verificar que la cantidad de reinas en el tablero es $n$. Además, no se detiene al encontrar una única solución, sino que determina todas las soluciones posibles y las guarda en las variable `soluciones`.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-9_149d213311577259a579eb5d264a869e'}\n\n```{.r .cell-code}\n  solve = function(board){\n      for (i in 1:queens) {\n        for (j in 1:queens) {\n          if(board[i,j] == 0){\n            if(possible(board,i,j,1)){ # Posición admisible\n              board[i,j] = 1\n              if(sum(board) == queens){ # Criterio de solución\n                solutions[[length(soluciones)+1]] <<- board\n                break()\n              }\n              solve(board) # Criterio recursivo\n              board[i,j] = 0\n            }\n          }\n        }\n      # Criterio de no admisibilidad\n      if(sum(board[i,]) == 0) return()\n    }\n  }\n\nsoluciones = list()\nsquare = matrix(0,ncol = queens, nrow = queens)\nsolve(square)\n\nprint(paste(\"All solutions: \",length(soluciones)))\nreturn(soluciones)\n\n}\n```\n:::\n\n\nAl inicio comentamos que la búsqueda es en profundidad, esto se debe a que la función `solve()` evalúa las posiciones de las reinas, según se recorren los ciclos `for`, de este modo, las posibles soluciones finales se recorren 1 a 1 en cada iteración.\n\nPara ejemplificar, evaluemos el problema con 5 reinas.\n\n\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-11_aebf36425235abcf835da82cfbc65738'}\n\n```{.r .cell-code}\n# Omití el argumento interactivo (readLine), para efectos del ejemplo\nr1 = opcion1(5) # Imprime el total de soluciones encontradas\n## [1] \"Cantidad de soluciones:  10\"\nr1[1] # La primera solución obtenida\n## [[1]]\n##      [,1] [,2] [,3] [,4] [,5]\n## [1,]    1    0    0    0    0\n## [2,]    0    0    1    0    0\n## [3,]    0    0    0    0    1\n## [4,]    0    1    0    0    0\n## [5,]    0    0    0    1    0\n```\n:::\n\n\nComo se puede aprecia, la solución muestra la distribución de las reinas en el tablero, en la cual, el 1 indica la presencia de una reina y el 0 la ausencia.\n\n## Opción 2\n\nEn primer lugar, se declara la función para definir la cantidad de reinas que se desean colocar en el tablero.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-12_4cf0121a17373c87a515e9de1e9eb715'}\n\n```{.r .cell-code}\noption2 = function(){\n\n  n = as.integer(readline(\"Número de reinas?: \"))\n  solutions = list()\n```\n:::\n\n\nLuego, a diferencia de la opción 1 se tiene una única función (`Reinas()`), más breve, que determina las posiciones de las reinas. Para ello, se trabaja con la siguiente propiedad: \"se considera como solución un vector que contenga la posición de cada reina en una determinada columna, siendo la posición en el vector la fila que le corresponde a dicha reina\".\n\nEl argumento que nos permite deducir esto lo puedes encontrar en estos [apuntes](Busqueda+en+paralelo.pdf). En el fondo, se recurre al hecho de que las soluciones pueden ordenarse convenientemente en un vector, esto permite que sea más fácil evaluar los distintas posibles soluciones.\n\nVolviendo a la función `Reinas()`, la variable `diags` guarda las casillas correspondientes a la proyección de las diagonales desde una fila a otra (ejemplo: desde la fila 1 y 2, a la fila 3), esto \"genera\" casillas que están fuera de la matriz, pero las cuales son eliminadas en la variable `posibles.columnas` que guarda las casillas en donde es admisible la posición de una reina. Esto permite resumir el problema a una \"proyección de diagonales\", eliminando los criterios de filas y columnas (genial!).\n\nFinalmente se hace uso de la recursividad mediante la función `apply()`. El resto de código imprime la cantidad total de soluciones y guarda las soluciones en forma matricial.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-13_b32b53fea93dc2a1d798b8eda76ca49f'}\n\n```{.r .cell-code}\n  Reinas = function(posiciones) {\n    \n    # Imprime la solución al momento de obtener 8 posiciones\n    # que cumplen las condiciones\n    if (length(posiciones) == n) {\n      soluciones[[length(soluciones)+1]] <<- posiciones\n    }\n    \n    # Se definen las columnas posibles en donde puede ir una reina\n    posibles.columnas = setdiff(1:n, posiciones)\n    \n    # Se definen las diagonales matriciales en donde no puede ir una reina\n    out.diags = seq(length(posiciones), 1)\n    diags = c(posiciones + out.diags, posiciones - out.diags)\n    diags = diags[diags >= 1 & diags <= n]\n    \n    # Se eliminan las casillas diagonales, de las casillas posibles\n    # en donde ubicar a una reina\n    posibles.columnas = setdiff(posibles.columnas, diags)\n    \n    # Para cada posibilidad se evalúa nuevamente la función\n    if(length(posibles.columnas > 0)){\n      apply(matrix(posibles.columnas), 1, FUN = function(p){\n        Reinas(c(posiciones,p)) # Se añaden las opciones\n                                # posibles a cada iteración\n      })\n    }\n  }\n  \n  Reinas(c())\n  \n  # Se imprime la cantidad de soluciones posibles\n  print(paste(\"Cantidad de soluciones: \",length(soluciones)))\n\n  # Se transforman las soluciones en matrices\n  soluciones = lapply(soluciones, function(sol){\n    M = matrix(0, ncol = n, nrow = n)\n    for (i in 1:n) {\n      M[i,sol[i]] = 1\n    }\n    return(M)\n  })\n  \n  # Se retornan las matrices solución\n  return(soluciones)\n}\n```\n:::\n\n\nComparemos lo obtenido con la opción 1.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-14_d959d9fd24893568b0a140a3b85bb145'}\n\n:::\n\n::: {.cell hash='index_cache/html/unnamed-chunk-15_b94ce02d27862b0df9a613003ed29b46'}\n\n```{.r .cell-code}\nr2 = opcion2(5)\n## [1] \"All solutions:  10\"\nr2[1]\n## [[1]]\n##      [,1] [,2] [,3] [,4] [,5]\n## [1,]    1    0    0    0    0\n## [2,]    0    0    1    0    0\n## [3,]    0    0    0    0    1\n## [4,]    0    1    0    0    0\n## [5,]    0    0    0    1    0\n```\n:::\n\n\nComo se puede apreciar, el resultado dado por la opción 1. Esto se debe a que los caminos se recorren en \"orden\", a esto se le llama solución lexicográfica.\n\n## Comentarios\n\nLos códigos son simplemente ejemplos, ya que para la primera opción es posible ocupar los mismos criterios que en la segunda. Es por esto, que la idea es proporcionar distintas alternativas, de tal manera que puedan aplicar y entender sus propias propuestas.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}